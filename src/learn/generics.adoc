---
title: Generics
date: 2018-12-05
description:
  Wrap up of hashing and a discussion of how to program with Java generics.
spelling_exceptions:
  - blockchain
  - Geez
  - SHA
  - Hashcash
  - generifying
---
:imagesdir: /learn/images

[[dCpHsyaBAaBpgNerMebmXnqvbeSuiedh]]
== !

[.janini.jdk.compiler.smaller]
--
++++
<div class="message">Generics</div>
++++
....
import java.util.List;
import java.util.ArrayList;

public class LastTen<T> {
  private List<T> values = new ArrayList<>(10);
  private int currentIndex = 0;
  LastTen() {
    for (int i = 0; i < 10; i++) {
      values.add(i, null);
    }
  }
  public void add(T newValue) {
    values.set(currentIndex, newValue);
    currentIndex = (currentIndex + 1) % 10;
  }
  public List<T> get() {
    return values;
  }
}
public class Example {
  public static void main(String[] unused) {
    LastTen<String> lastTen = new LastTen<>();
    for (int i = 0; i < 30; i++) {
      lastTen.add("foo" + i);
    }
    System.out.println(lastTen.get());
  }
}
....
--

[[BFsbQonOROfQfifbDIJlLLgeMhdrjZBu]]
== Cryptographic Hash Function

Hash functions already provide:

[.small]
//
* *Determinism*: it can convert an arbitrary amount of data into a single
limited-size value. If we repeat the computation on the same data, we get the
same value.
//
* *Uniformity*: over many inputs, each output value is equally likely.
//
* [.line-through]#*Efficiency*: it is efficient to compute.#

But what if there were hash functions with the following _new_ properties:

[.s.small]
//
* Given the hash, it is _infeasible_ to determine the original input
//
* A small change to the input produces a _large_ change in the output
//
* The function is _difficult_ to compute, not easy

[[ahHxfzfBcLQvvuWqeAEfuFsGFcjqWsMQ]]
== Cryptographic Hash Functions

[.lead]
//
A hash function that satisfies these properties is known as a _cryptographic
hash function_, largely because they are ubiquitous in modern cryptography.

[[PdxviDVjqwEyJNsBsEAQRzzhphhYRviR]]
== A Simple Example

[.lead]
//
I need to be able to check your password, but I don't want to save it.
//
*Is that possible?*

[.s.small]
//
* *Yes!*
//
* Save the cryptographic hash of your password, not the password itself.
//
* When you submit your password, I hash it and compare it with the saved hash.
//
* If someone steals my database, they can't recover the original passwords.
//
** Given the hashes, you can't recover the original passwords
//
** Hash values reveal nothing about how close you are to the actual password
//
** Hashing inputs to test them is expensive

[[sqifxqIMMsbqDxLiLedePYbVGYpYDhzx]]
== A Modern Example

[.lead]
//
Heard of blockchain?

Blocks are linked through _cryptographic hashes_.
//
And the blockchain is secured through an old idea called
//
https://en.wikipedia.org/wiki/Hashcash[Hashcash].

[.s]
//
* Given a hash value of a given size, I can estimate how much work you'll have
to do to guess the input that produced that value
//
* So I can force you to do that work and verify that you did it easily by
hashing the value that you gave me

[[gRZDKTXJypxDiTAoVSSwTfZOMUNyUxCG]]
== Hashcash Example

[.s]
//
* Alice: "Here's a challenge for you Bob, find an input that produces hash
`39c3aa4015e7964914c311915316a2f78157c946`.
* Bob: "Geez, that's hard. Give me a few minutes... OK, got it."
//
* Alice: "Wow, you're right. I computed the hash and it's
`39c3aa4015e7964914c311915316a2f78157c946` that must have been hard."

[[guRSGeBImDPQydnsrPLxWGdCcxlgidXd]]
== Blockchain Proof of Work

++++
<div class="embed-responsive embed-responsive-4by3">
  <iframe class="full embed-responsive-item" src="https://en.bitcoin.it/wiki/Proof_of_work"></iframe>
</div>
++++

[[qGSmwzyNQfEsKimoddEsPTmTCROlLAfV]]
[.oneword]
//
== Unintended Consequences

Hashcash was intended to help fight spam. Now it's the reason that Bitcoin
mining
//
https://www.nytimes.com/2018/01/21/technology/bitcoin-mining-energy-consumption.html[is
ruining the planet].

[[aGqRxSJOrbpxveHPtfUbwZvbJQMzOGnp]]
== And, Beautiful Theory

[quote]
____
In computer science, a
//
https://en.wikipedia.org/wiki/One-way_function[one-way function]
//
is a function that is easy to compute on every input, but hard to invert given
the function's output for a random input.

*The existence of such one-way functions is still an open conjecture.*
//
In fact, their existence would prove that the complexity classes P and NP are
not equal, thus resolving the foremost unsolved question of theoretical computer
science.
//
____

[[jXRuKfHWdQnxhqBYQQVMOPSJlRrttssh]]
[.oneword]
//
== Questions About Hashing?

[[aPkedSJgDzeujqwbdAasRSTZJjBMUVbF]]
== Java Generics

[.lead]
//
Lists and maps are the two data structures you meet in heaven.
//
Together you can use them to solve almost any problem.

But you'll usually use Java`s built-in implementations.

[source,java,role='smaller']
----
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

import java.util.Map;
import java.util.HashMap;
import java.util.TreeMap;

List list = new ArrayList();
List anotherList = new LinkedList();
Map map = new HashMap();
Map anotherMap = new TreeMap();
----

[[VazQjvfefhYtQVZbbAfnIinPqkOhFcuL]]
== ! Bare ``ArrayList``s and ``HashMap``s

[.janini.jdk.compiler.smaller]
....
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class Example {
  public static void main(String[] unused) {
    List list = new ArrayList();
    // What goes in is a string...
    list.add("string");
    // But what comes out is an Object
    String s = list.get(0);
    // We can downcast this, but that's not safe

    Map map = new HashMap();
    // Keys and values can be any Java object...
    map.put("key", 8);
    // But what comes out is an Object
    Integer i = map.get("key");
    // We can downcast this, but that's (still) not safe
  }
}
....

[[CfhXqjfTVWkvvUQsiviIgULshCtvBoql]]
== Compiler Errors v. Runtime Errors

[.lead]
//
Java and many languages that followed it have tried to transform _runtime_
errors into _compiler_ errors.
//
*Why?*

[.s]
//
* You compile your code _before_ it runs: and so before you have to demo it to a
client, or before you deploy it to hundreds of users.
//
* Catching errors at this stage is _critical_.

[[CAmWlXhrXPgQfqJnzxuEyMbiMZcmBlDK]]
== Generics

[.lead]
//
Java generics allow us to create reusable classes while allowing the compiler to
check our code for correctness.

Type parameters tell the compiler what we are going to do with each data
structure.

[source,java,role='smaller']
----
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

List<Integer> integerlist = new ArrayList<>(); // This is list of Integers
Map<Integer, String> = new HashMap<>(); // This maps Integers to Strings
----

[[icfvQmfITTojvuLTENxWELDeeUJPWeWO]]
== ! Generic ``ArrayList``s

[.janini.jdk.compiler.smaller]
....
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class Example {
  public static void main(String[] unused) {
    List<String> list = new ArrayList<>();
    // What goes in is a string...
    list.add("string");
    // What comes out is a string
    String s = list.get(0);
    // I can't add Objects that aren't Strings or don't descend from String
    list.add(new Integer(10));

    Map<String, Integer> map = new HashMap<>();
    // The compiler can check my mappings...
    map.put("key", 8);
    // And cast what comes out safely for me
    Integer i = map.get("key");
    // I can't add invalid mappings
    map.put(8, 10);
  }
}
....

[[xeDYzlBEYAuWmiyunissqSphJYPGdfRN]]
== ! Generics In Documentation

++++
<div class="embed-responsive embed-responsive-4by3">
  <iframe class="embed-responsive-item" src="https://docs.oracle.com/javase/10/docs/api/java/util/Map.html"></iframe>
</div>
++++

[[ufnapiBBDPHnqhSKjaQWNGdfyDcOWJVS]]
[.oneword]
//
== Generifying Your Classes

[.lead]
//
So we know how to use existing generic class.
//
But how do we provide our own?

[[gshanQpcjpeifKipeXsEwdwgrcRXdvee]]
== Class Type Parameters

[.lead]
//
First, we have to declare our class to accept _type parameters_:

[source,java]
----
// T is a type parameter that can be used throughout our class
public class SimpleLinkedList<E> {
  // get returns a reference of type E
  public E get(int index) {
  }
  // set takes a reference of type T as its second argument
  public void set(int index, E value) {
  }
}
----

[[PmTBHbqtdzEwfOnTUNQqNLKNbdNtCnsc]]
== Parameters Are Not Variables

[.lead]
//
Class parameters _are not_ variables.

I can use them where I would normally provide a type, but I can't get or set
their values.

[source,java]
----
public class SimpleLinkedList<E> {
  // I can use the parameter here as a return type...
  public E get(int index) {
    E = String; // But I can't do something like this
  }
}
----

[[yFUOEpPuuncaCyOreneyqcdTWzAeDgTn]]
== Compiling Generic Classes

[.lead]
//
To help understand how generics work you can imagine the compiler rewriting them
when it compiles your code.

[[nIOLajpCRkeiqzqdfVGABscHwBcJsFPJ]]
[.ss]
//
== Original and Rewritten Class

[source,java,role='smallest']
----
public class List<E> {
  public E get(int i) {
  }
  public void set(int i, E value) {
  }
}
List<String> list = new List<>();
----

<<<

[source,java,role='smallest s']
----
public class List {
  public String get(int i) {
  }
  public void set(int i, String value) {
  }
}
List list = new List<>();
----

[[rjGEMqeTIbLcWeCtNxiOeLLUdiZedeEI]]
[.ss]
//
== Original and Rewritten Class

[source,java,role='smallest']
----
public class List<E> {
  public E get(int i) {
  }
  public void set(int i, E value) {
  }
}
List<Integer> list = new List<>();
----

<<<

[source,java,role='smallest s']
----
public class List {
  public Integer get(int i) {
  }
  public void set(int i, Integer value) {
  }
}
List list = new List<>();
----

[[PIyilhvdeQiJwljjSFmLVauXiVUleFhn]]
== Type Erasure

[.lead]
//
**Note that this is not actually what happens.**

[.s]
//
* The compiler only creates _one_ instance of each generic class
//
* Type information is used during compilation to check access but then
_erased_
//
* But this isn't a bad mental model of how generics work in practice

[[OrueWINOdsdAZvLfddaaMKJoRgIuUxJS]]
== Multiple Type Parameters

[.lead]
//
Classes can use one or several type parameters:

[source,java]
----
// This is a generic list storing elements of type T
public class SimpleLinkedList<T> { }

// This is a generic map mapping elements of type K to type V
public class SimpleMap<K,V> { }
----

[[drYDduyVUSIMCAtgQvtfToxfemixBIsy]]
== Parameter Naming Conventions

[.lead]
//
To avoid confusing type parameters with variable names or other keywords, Java
has established conventions for naming them.

[.s.small]
//
* **By convention** type names are single uppercase letters: `T`, `K`, `V`, `E`,
etc.
//
* Note that this is just a convention: it's not enforced by the compiler
//
* Certain type parameters have conventional meanings:
//
** `E` for element (which we'll use for our lists)
//
** `K` for key and `V` for value, (which we'll use for our maps)
//
** `N` for a number

[[NatQECjiehpGWjBTDhWNjopXkXVqFVZq]]
== Announcements

* Your first link:/MP/6/[final project checkpoint is in lab this week].
//
* I have office hours MWF from 10AM&ndash;12PM in Siebel 2227.
//
Please stop by!
//
* Remember to provide feedback on the course using the
//
https://cs125.cs.illinois.edu/info/feedback/[anonymous feedback form].
//
* I've started to respond to existing feedback
//
https://cs125-forum.cs.illinois.edu/c/feedback[on the forum].

// vim: ts=2:sw=2:et
